// src/adapters/mongoUserAdapter.js
/**
 * @fileoverview MongoDB User Store Adapter.
 * Implements UserStoreAdapter for MongoDB using Mongoose.
 */
const mongoose = require('mongoose');
const UserStoreAdapter = require('./userStoreAdapter');
const UserModel = require('./mongoUserModel'); // Mongoose User model
const { mongoUri } = require('../../config'); // Get MONGO_URI from main config
const logger = require('../../config/logger'); // Use shared logger

class MongoUserAdapter extends UserStoreAdapter {
  constructor() {
    super();
    this.connect();
  }

  async connect() {
    if (mongoose.connection.readyState === 0) { // 0 = disconnected
      try {
        logger.info('Connecting to MongoDB...');
        await mongoose.connect(mongoUri, {
          // useNewUrlParser: true, // Deprecated in Mongoose 6+
          // useUnifiedTopology: true, // Deprecated in Mongoose 6+
          // useCreateIndex: true, // Deprecated, Mongoose 6+ handles this by default
          // useFindAndModify: false, // Deprecated
        });
        logger.info('MongoDB connected successfully.');

        mongoose.connection.on('error', (err) => {
          logger.error('MongoDB connection error after initial connection:', err);
        });
        mongoose.connection.on('disconnected', () => {
          logger.warn('MongoDB disconnected.');
        });

      } catch (error) {
        logger.error('Initial MongoDB connection error:', error);
        // Optionally exit process if DB connection is critical for startup
        // process.exit(1);
      }
    }
  }

  async disconnect() { // For graceful shutdown
    if (mongoose.connection.readyState !== 0) {
      await mongoose.disconnect();
      logger.info('MongoDB disconnected due to app shutdown.');
    }
  }

  async findUserById(id) {
    // UserModel.findById expects the _id field. Our _id is custom.
    return UserModel.findById(id).exec();
  }

  async findUserByProfileId(profileId, provider) {
    return UserModel.findOne({ provider, providerId }).exec();
  }

  async findOrCreateUser(profileDetails) {
    // profileDetails: { providerId, provider, displayName, email, photo }
    const existingUser = await this.findUserByProfileId(profileDetails.providerId, profileDetails.provider);

    if (existingUser) {
      // Update existing user if necessary (e.g., displayName, photo)
      let updated = false;
      if (profileDetails.displayName && existingUser.displayName !== profileDetails.displayName) {
        existingUser.displayName = profileDetails.displayName;
        updated = true;
      }
      if (profileDetails.email && existingUser.email !== profileDetails.email.toLowerCase()) {
        existingUser.email = profileDetails.email.toLowerCase();
        updated = true;
      }
      if (profileDetails.photo && existingUser.photo !== profileDetails.photo) {
        existingUser.photo = profileDetails.photo;
        updated = true;
      }
      // Ensure refreshTokens array exists
      if (!Array.isArray(existingUser.refreshTokens)) {
        existingUser.refreshTokens = [];
        updated = true;
      }

      if (updated) {
        await existingUser.save();
      }
      return existingUser.toObject(); // Return plain object
    }

    // Create new user
    const newUser = new UserModel({
      // _id will be auto-generated by pre-save hook: `${profileDetails.provider}-${profileDetails.providerId}`
      provider: profileDetails.provider,
      providerId: profileDetails.providerId,
      displayName: profileDetails.displayName,
      email: profileDetails.email ? profileDetails.email.toLowerCase() : null,
      photo: profileDetails.photo,
      refreshTokens: [], // Initialized by schema default but good to be explicit
    });
    await newUser.save();
    return newUser.toObject(); // Return plain object
  }

  async addRefreshToken(userId, refreshToken) {
    const user = await UserModel.findById(userId);
    if (user) {
      if (!user.refreshTokens.includes(refreshToken)) {
        user.refreshTokens.push(refreshToken);
        await user.save();
      }
      return true;
    }
    return false;
  }

  async validateRefreshToken(userId, refreshToken) {
    const user = await UserModel.findById(userId);
    if (user) {
      return user.refreshTokens.includes(refreshToken);
    }
    return false;
  }

  async removeRefreshToken(userId, refreshToken) {
    const user = await UserModel.findById(userId);
    if (user && user.refreshTokens) {
      const initialLength = user.refreshTokens.length;
      user.refreshTokens = user.refreshTokens.filter(rt => rt !== refreshToken);
      if (user.refreshTokens.length < initialLength) {
        await user.save();
        return true;
      }
    }
    return false;
  }

  async clearAllUsers() {
    // Primarily for testing environments. Use with caution.
    if (process.env.NODE_ENV === 'test') {
      await UserModel.deleteMany({});
      logger.info('MockUserStore (MongoDB): All users cleared.');
    } else {
      logger.warn('clearAllUsers called outside of test environment. Operation aborted.');
      throw new Error('clearAllUsers is only permitted in test environment.');
    }
  }
}

module.exports = MongoUserAdapter;
